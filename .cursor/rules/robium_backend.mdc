# Robium Backend Development Rules

## Express.js Server Patterns

### Route Handler Structure
```typescript
// ‚úÖ DO: Use async/await with proper error handling
app.get('/api/users/:id', async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;
    const user = await Database.query(
      'SELECT id, email, username, role FROM users WHERE id = $1',
      [id]
    );
    
    if (user.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.json({
      success: true,
      data: user.rows[0]
    });
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// ‚ùå DON'T: Missing error handling or type safety
app.get('/api/users/:id', (req, res) => {
  const user = Database.query('SELECT * FROM users WHERE id = ' + req.params.id);
  res.json(user); // No error handling, SQL injection risk
});
```

### Middleware Patterns
```typescript
// ‚úÖ DO: Create reusable middleware with proper typing
export const authMiddleware = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

// Use in routes
app.get('/api/protected', authMiddleware, async (req: AuthRequest, res) => {
  // req.user is now available and typed
});
```

## Database Operation Patterns

### Query Patterns
```typescript
// ‚úÖ DO: Use parameterized queries with proper error handling
export class UserModel {
  static async findById(id: string): Promise<User | null> {
    try {
      const result = await Database.query(
        'SELECT id, email, username, role, created_at, updated_at FROM users WHERE id = $1',
        [id]
      );
      return result.rows[0] || null;
    } catch (error) {
      console.error('Error finding user by ID:', error);
      throw new Error('Failed to fetch user');
    }
  }
  
  static async create(userData: CreateUserInput): Promise<User> {
    const { email, username, password, role = UserRole.USER } = userData;
    const passwordHash = await bcrypt.hash(password, 12);
    
    try {
      const result = await Database.query(
        `INSERT INTO users (email, username, password_hash, role) 
         VALUES ($1, $2, $3, $4) 
         RETURNING id, email, username, role, created_at, updated_at`,
        [email, username, passwordHash, role]
      );
      return result.rows[0];
    } catch (error) {
      if (error.code === '23505') { // Unique constraint violation
        throw new Error('Email or username already exists');
      }
      console.error('Error creating user:', error);
      throw new Error('Failed to create user');
    }
  }
}

// ‚ùå DON'T: String concatenation or missing error handling
const user = await Database.query(`SELECT * FROM users WHERE email = '${email}'`);
```

### Transaction Patterns
```typescript
// ‚úÖ DO: Use transactions for multi-step operations
export class ProjectService {
  static async createProjectWithMember(projectData: CreateProjectInput, ownerId: string) {
    return await Database.transaction(async (client) => {
      // Create project
      const project = await client.query(
        'INSERT INTO projects (name, description, owner_id) VALUES ($1, $2, $3) RETURNING *',
        [projectData.name, projectData.description, ownerId]
      );
      
      // Add owner as project member
      await client.query(
        'INSERT INTO project_members (project_id, user_id, role) VALUES ($1, $2, $3)',
        [project.rows[0].id, ownerId, 'owner']
      );
      
      return project.rows[0];
    });
  }
}
```

## Migration Patterns

### Migration File Structure
```sql
-- ‚úÖ DO: Always include both UP and DOWN sections
-- UP
CREATE TABLE example_table (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_example_email ON example_table(email);

-- DOWN
DROP INDEX IF EXISTS idx_example_email;
DROP TABLE IF EXISTS example_table;
```

### Migration Commands
```bash
# ‚úÖ DO: Use the established migration commands
npm run migrate:up        # Run pending migrations
npm run migrate:down      # Rollback last migration
npm run migrate:status    # Check migration status
npm run migrate:reset     # Reset all migrations (destructive)
```

## TypeScript Patterns

### Type Definitions
```typescript
// ‚úÖ DO: Define interfaces in src/types/index.ts
export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserInput {
  email: string;
  username: string;
  password: string;
  role?: UserRole;
}

export interface AuthRequest extends Request {
  user?: JWTPayload;
}

// ‚ùå DON'T: Use any types or inline interfaces
const user: any = await getUser(); // Bad
```

### API Response Types
```typescript
// ‚úÖ DO: Use consistent API response structure
export interface ApiResponse<T = any> {
  success: boolean;
  message?: string;
  data?: T;
  error?: string;
}

// Usage in routes
res.json({
  success: true,
  data: user,
  message: 'User retrieved successfully'
} as ApiResponse<User>);
```

## Authentication & Security

### Password Hashing
```typescript
// ‚úÖ DO: Use bcrypt with appropriate rounds
import bcrypt from 'bcryptjs';

const hashPassword = async (password: string): Promise<string> => {
  return await bcrypt.hash(password, 12); // 12 rounds for security
};

const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return await bcrypt.compare(password, hash);
};
```

### JWT Handling
```typescript
// ‚úÖ DO: Use environment variables for secrets
const generateToken = (payload: JWTPayload): string => {
  return jwt.sign(payload, process.env.JWT_SECRET!, {
    expiresIn: process.env.JWT_EXPIRES_IN || '1h'
  });
};

const verifyToken = (token: string): JWTPayload => {
  return jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;
};
```

## Environment Configuration

### Environment Variables
```typescript
// ‚úÖ DO: Use environment variables for configuration
const config = {
  port: process.env.PORT || 8000,
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'robiumdb',
    user: process.env.DB_USER || 'user',
    password: process.env.DB_PASSWORD || 'password'
  },
  jwt: {
    secret: process.env.JWT_SECRET!,
    expiresIn: process.env.JWT_EXPIRES_IN || '1h'
  }
};

// ‚ùå DON'T: Hardcode sensitive values
const secret = 'hardcoded-secret'; // Never do this
```

## Testing Patterns

### Jest Test Structure
```typescript
// ‚úÖ DO: Use proper test structure with setup/teardown
describe('UserModel', () => {
  beforeEach(async () => {
    await Database.query('BEGIN');
  });
  
  afterEach(async () => {
    await Database.query('ROLLBACK');
  });
  
  describe('findById', () => {
    it('should return user when found', async () => {
      // Create test user
      const user = await UserModel.create({
        email: 'test@example.com',
        username: 'testuser',
        password: 'password123'
      });
      
      // Test retrieval
      const found = await UserModel.findById(user.id);
      expect(found).toMatchObject({
        id: user.id,
        email: 'test@example.com',
        username: 'testuser'
      });
    });
    
    it('should return null when user not found', async () => {
      const found = await UserModel.findById('non-existent-id');
      expect(found).toBeNull();
    });
  });
});
```

## File Organization

### Directory Structure
```
packages/backend/src/
‚îú‚îÄ‚îÄ index.ts              # Express server entry point
‚îú‚îÄ‚îÄ routes/               # API route handlers
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts          # Authentication routes
‚îÇ   ‚îú‚îÄ‚îÄ users.ts         # User management routes
‚îÇ   ‚îî‚îÄ‚îÄ projects.ts      # Project management routes
‚îú‚îÄ‚îÄ models/              # Data models and business logic
‚îÇ   ‚îú‚îÄ‚îÄ User.ts          # User model
‚îÇ   ‚îú‚îÄ‚îÄ Project.ts       # Project model
‚îÇ   ‚îî‚îÄ‚îÄ Session.ts       # Session model
‚îú‚îÄ‚îÄ middleware/          # Express middleware
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts          # Authentication middleware
‚îÇ   ‚îú‚îÄ‚îÄ validation.ts    # Input validation middleware
‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.ts  # Global error handling
‚îú‚îÄ‚îÄ utils/               # Utility functions
‚îÇ   ‚îú‚îÄ‚îÄ database.ts      # Database connection and helpers
‚îÇ   ‚îú‚îÄ‚îÄ migrations.ts    # Migration system
‚îÇ   ‚îî‚îÄ‚îÄ validation.ts    # Validation helpers
‚îú‚îÄ‚îÄ types/               # TypeScript type definitions
‚îÇ   ‚îî‚îÄ‚îÄ index.ts         # All shared types
‚îú‚îÄ‚îÄ migrations/          # Database migration files
‚îÇ   ‚îî‚îÄ‚îÄ 001_initial_schema.sql
‚îú‚îÄ‚îÄ scripts/             # CLI scripts
‚îÇ   ‚îî‚îÄ‚îÄ migrate.ts       # Migration CLI
‚îî‚îÄ‚îÄ __tests__/           # Test files
    ‚îú‚îÄ‚îÄ setup.ts         # Test setup and configuration
    ‚îú‚îÄ‚îÄ models/          # Model tests
    ‚îî‚îÄ‚îÄ routes/          # Route tests
```

## Error Handling

### Global Error Handler
```typescript
// ‚úÖ DO: Implement comprehensive error handling
app.use((err: ApiError, req: Request, res: Response, next: NextFunction) => {
  console.error('Error:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  res.status(err.status || 500).json({
    success: false,
    error: err.message || 'Internal Server Error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});
```

### Custom Error Classes
```typescript
// ‚úÖ DO: Create custom error types
export class ValidationError extends Error {
  status = 400;
  constructor(message: string, public errors?: ValidationError[]) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends Error {
  status = 404;
  constructor(resource: string) {
    super(`${resource} not found`);
    this.name = 'NotFoundError';
  }
}
```

## WebSocket Integration

### WebSocket Server Setup
```typescript
// ‚úÖ DO: Integrate WebSocket with Express server
import { WebSocketServer } from 'ws';
import { createServer } from 'http';

const server = createServer(app);
const wss = new WebSocketServer({ server });

wss.on('connection', (ws, req) => {
  console.log('New WebSocket connection');
  
  ws.on('message', async (message) => {
    try {
      const data = JSON.parse(message.toString());
      // Handle WebSocket messages
      await handleWebSocketMessage(ws, data);
    } catch (error) {
      ws.send(JSON.stringify({ error: 'Invalid message format' }));
    }
  });
  
  ws.on('close', () => {
    console.log('WebSocket connection closed');
  });
});
```

## Development Workflow

### Server Startup
```typescript
// ‚úÖ DO: Initialize database and run migrations on startup
async function startServer() {
  try {
    // Connect to database
    await Database.connect();
    
    // Run pending migrations
    const migrationManager = new MigrationManager();
    await migrationManager.runPendingMigrations();
    
    // Start server
    server.listen(PORT, () => {
      console.log(`üöÄ Robium Backend Server running on port ${PORT}`);
      console.log(`üì° WebSocket server ready for connections`);
      console.log(`üóÉÔ∏è  Database connected and migrations applied`);
    });
  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}
```

Follow these patterns consistently throughout the backend codebase. Reference [database.ts](mdc:packages/backend/src/utils/database.ts) and [migrations.ts](mdc:packages/backend/src/utils/migrations.ts) for implementation examples.
description:
globs:
alwaysApply: false
---
